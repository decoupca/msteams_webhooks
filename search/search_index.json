{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"msteams_webhooks","text":"<p>A modern Python API for sending messages to Microsoft Teams using webhooks. Requires Python 3.9+.</p> <p>Unstable API</p> <p>This package is in early development and may introduce breaking changes. You can expect a stable API in the 1.0.0 release.</p>"},{"location":"#intro","title":"Intro","text":"<p>Instead of plaintext messages, Microsoft Teams uses JSON data structures called cards. This package aims to simplify creating and sending these cards by building these data structures for you, using simple and well-documented Python objects.</p>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#install","title":"Install","text":"<p>Until the package reaches stability, this package will not be added to PyPI. For now, install it from git:</p> <pre><code>pip install git+https://github.com/decoupca/msteams_webhooks.git\n</code></pre>"},{"location":"#create-a-webhook-url","title":"Create a Webhook URL","text":"<p>Follow this guide to create a webhook URL for your channel.</p>"},{"location":"#send-a-basic-message","title":"Send a Basic Message","text":"<pre><code>from msteams_webhooks import TeamsWebhook\n\nchannel = TeamsWebhook('&lt;your-webhook-url&gt;')\nchannel.send_message(\"Hello, World!\")\n</code></pre> <p>Behind the scences, this creates an Adaptive Card and adds a single <code>TextBlock</code> element to the body before sending it to the channel.</p>"},{"location":"#customize-the-message","title":"Customize the Message","text":"<p>You can further customize the message with all properties supported by a <code>TextBlock</code> element. For example:</p> <pre><code>channel.send_message(\n    text=\"Hello, World!\",\n    color=\"good\",\n    horizontal_alignment=\"center\",\n    font_size=\"large\",\n    weight=\"bolder\"\n)\n</code></pre> <p>The <code>text</code> property also supports a subset of Markdown formatting syntax.</p>"},{"location":"#manually-build-a-card","title":"Manually Build a Card","text":"<p>Hero Cards provide a simple example of building a card from scratch.</p> <p>Here's how to build the example Hero Card from the documentation:</p> <pre><code>from msteams_webhooks import TeamsWebhook\nfrom msteams_webhooks.buttons import OpenURLButton\nfrom msteams_webhooks.cards import AdaptiveCard, HeroCard\nchannel = TeamsWebhook('&lt;your-webhook-url&gt;')\nofficial_website = OpenURLButton(\n    title=\"Official website\",\n    url=\"https://www.seattlemonorail.com\"\n)\nwikipedia_page = OpenURLButton(\n    title=\"Wikipedia page\",\n    url=\"https://en.wikipedia.org/wiki/Seattle_Center_Monorail\"\n)\ncard = HeroCard(\n    title='Seattle Center Monorail',\n    subtitle='Seattle Center Monorail',\n    text=(\"The Seattle Center Monorail is an elevated train line between Seattle Center \"\n            \"(near the Space Needle) and downtown Seattle. It was built for the 1962 World's Fair. \"\n            \"Its original two trains, completed in 1961, are still in service.\"),\n    images=[\"https://upload.wikimedia.org/wikipedia/commons/thumb/4/49/Seattle_monorail01_2008-02-25.jpg/1024px-Seattle_monorail01_2008-02-25.jpg\"],\n    buttons=[official_website, wikipedia_page]\n)\nchannel.send_card(card)\n</code></pre>"},{"location":"advanced/","title":"Advanced","text":""},{"location":"advanced/#inspecting-json-payloads","title":"Inspecting JSON Payloads","text":"<p>You can inspect any object's JSON payload by calling its <code>serialize()</code> method. This may be helpful when debugging, or learning about an object's schema.</p> <pre><code>&gt;&gt;&gt; from msteams_webhooks import TeamsWebhook, AdaptiveCard, TextBlock\n&gt;&gt;&gt; import pprint\n&gt;&gt;&gt; channel = TeamsWebhook('&lt;your-webhook-url&gt;')\n&gt;&gt;&gt; card = AdaptiveCard()\n&gt;&gt;&gt; text_block = TextBlock(text=\"Hello, World!\", color='good', weight='bolder')\n&gt;&gt;&gt; card.body.append(text_block)\n&gt;&gt;&gt; pprint.pprint(card.serialize())\n{'content': {'$schema': 'http://adaptivecards.io/schemas/adaptive-card.json',\n             'body': [{'color': 'good',\n                       'text': 'Hello, World!',\n                       'type': 'TextBlock',\n                       'weight': 'bolder'}],\n             'type': 'AdaptiveCard',\n             'version': '1.5'},\n 'contentType': 'application/vnd.microsoft.card.adaptive'}\n</code></pre>"},{"location":"advanced/#http-tuning","title":"HTTP Tuning","text":""},{"location":"advanced/#https-certificate-verification","title":"HTTPS Certificate Verification","text":"<p>You can provide a custom CA cert bundle directly to <code>TeamsWebhook</code>:</p> <pre><code>channel = TeamsWebhook(url='&lt;your-webhook-url&gt;', verify='/path/to/internal/ca.pem')\n</code></pre> <p>Or, disable verification altogether with <code>verify=False</code>.</p>"},{"location":"advanced/#adjusting-timeouts","title":"Adjusting Timeouts","text":"<p>You can override the default 15sec timeout when constructing <code>TeamsWebhook</code>:</p> <pre><code>channel = TeamsWebhook(url='&lt;your-webhook-url&gt;', timeout=30.0)\n</code></pre> <p>You can further tune timeouts using options provided by <code>httpx</code>, if necessary.</p>"},{"location":"advanced/#advanced-http-tuning","title":"Advanced HTTP Tuning","text":"<p>All webhook requests are dispatched by an <code>httpx.Client</code> instance, stored in the <code>TeamsWebhook.client</code> property. For full control over all HTTP options, you can create your own client and replace the <code>client</code> property:</p> <pre><code>from msteams_webhooks import TeamsWebhook\nimport httpx\n\nchannel = TeamsWebhook('&lt;your-webhook-url&gt;')\nchannel.client = httpx.Client(...)\n</code></pre>"},{"location":"advanced/#limitations","title":"Limitations","text":""},{"location":"advanced/#mentions","title":"Mentions","text":""},{"location":"advanced/#whole-channel","title":"Whole Channel","text":"<p>There is currently no way to notify/mention the whole channel using webhooks. This feature is only available to Bots.</p>"},{"location":"advanced/#individuals","title":"Individuals","text":"<p>The Teams webhooks API does support mentioning individuals. However, the approach is somewhat complex and has not yet been implemented by <code>msteams_webhooks</code>.</p>"},{"location":"advanced/#roadmap","title":"Roadmap","text":""},{"location":"advanced/#near-term","title":"Near-term","text":"<p>Features for 1.0.0: * Implement all elements, actions, and container objects relevant to webhooks.</p>"},{"location":"advanced/#mid-term","title":"Mid-term","text":"<ul> <li>Add support for mentioning individuals in Adaptive Cards.</li> <li>Implement an <code>AsyncTeamsWebhook</code> class.</li> </ul>"},{"location":"building_cards/","title":"Building Cards","text":"<p>Cards form the basis of any Teams message.</p> <p>The most common and flexible card is the Adaptive Card. Adaptive Cards may include any combination of text, images, and media inside any number of containers.</p> <p>Let's build a basic Adaptive Card using inline objects:</p> <pre><code>from msteams_webhooks import AdaptiveCard, Image, TextBlock\ncard = AdaptiveCard(body=[\n    Image(url=\"https://adaptivecards.io/content/cats/1.png\", alt_text=\"Cat\"),\n    TextBlock(text=\"This is a picture of a cat.\")\n])\n</code></pre> <p>You can also build cards incrementally:</p> <pre><code>from msteams_webhooks import AdaptiveCard, Image, TextBlock\ncard = AdaptiveCard()\nimage = Image(url=\"https://adaptivecards.io/content/cats/1.png\", alt_text=\"Cat\")\ntext_block = TextBlock(text=\"This is a picture of a cat.\")\ncard.body.extend(image, text_block)\n</code></pre> <p>You can also change properties of any object after building it:</p> <pre><code>text_block.text = \"This text will overwrite the text provided above.\"\n</code></pre>"},{"location":"building_cards/#sending-cards","title":"Sending Cards","text":"<p>Sending cards to a Teams channel requires a webhook URL. Follow this guide to get one for your channel.</p> <p>Then, build a <code>TeamsWebhook</code> instance to send the card:</p> <pre><code>from msteams_webhooks import TeamsWebhook\nchannel = TeamsWebhook('&lt;your-webhook-url&gt;')\nchannel.send_card(card)\n</code></pre> <p>The <code>TeamsWebhook</code> class handles all HTTP-related tasks. Have a look at [Advanced] for tuning options.</p>"},{"location":"reference/actions/","title":"Actions","text":"<p>Actions provide ways to interact with cards.</p> <p>Not all actions defined in the Adaptive Card standard work with webhooks. Only those actions which work with webhooks are implemented.</p>"},{"location":"reference/actions/#msteams_webhooks.actions.Action","title":"<code>Action</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Base action class.</p> Source code in <code>msteams_webhooks/actions.py</code> <pre><code>class Action(Entity):\n\"\"\"Base action class.\"\"\"\n</code></pre>"},{"location":"reference/actions/#msteams_webhooks.actions.OpenURLAction","title":"<code>OpenURLAction</code>","text":"<p>         Bases: <code>Action</code></p> <p>Opens a URL when clicked or tapped.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Action.OpenUrl.html</p> Source code in <code>msteams_webhooks/actions.py</code> <pre><code>class OpenURLAction(Action):\n\"\"\"Opens a URL when clicked or tapped.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Action.OpenUrl.html\n    \"\"\"\n\n    def __init__(\n        self,\n        url: types.URL,\n        *,\n        title: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"Open a URL.\n\n        When invoked, show the given url either by launching it in an external web browser\n        or showing within an embedded web browser.\n\n        Args:\n            url: The URL to open.\n            title: Label for button or link that represents this action.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.url = url\n        self.title = title\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\n            \"type\": \"Action.OpenUrl\",\n            \"url\": self.url,\n        }\n        if self.title:\n            payload[\"title\"] = self.title\n        return payload\n</code></pre>"},{"location":"reference/actions/#msteams_webhooks.actions.OpenURLAction.__init__","title":"<code>__init__(url, *, title=None)</code>","text":"<p>Open a URL.</p> <p>When invoked, show the given url either by launching it in an external web browser or showing within an embedded web browser.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>types.URL</code> <p>The URL to open.</p> required <code>title</code> <code>Optional[str]</code> <p>Label for button or link that represents this action.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/actions.py</code> <pre><code>def __init__(\n    self,\n    url: types.URL,\n    *,\n    title: Optional[str] = None,\n) -&gt; None:\n\"\"\"Open a URL.\n\n    When invoked, show the given url either by launching it in an external web browser\n    or showing within an embedded web browser.\n\n    Args:\n        url: The URL to open.\n        title: Label for button or link that represents this action.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.url = url\n    self.title = title\n</code></pre>"},{"location":"reference/actions/#msteams_webhooks.actions.OpenURLAction.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/actions.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\n        \"type\": \"Action.OpenUrl\",\n        \"url\": self.url,\n    }\n    if self.title:\n        payload[\"title\"] = self.title\n    return payload\n</code></pre>"},{"location":"reference/buttons/","title":"Buttons","text":"<p>Buttons are interactive elements available to use in Hero Cards.</p>"},{"location":"reference/buttons/#msteams_webhooks.buttons.Button","title":"<code>Button</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Base button class.</p> Source code in <code>msteams_webhooks/buttons.py</code> <pre><code>class Button(Entity):\n\"\"\"Base button class.\"\"\"\n</code></pre>"},{"location":"reference/buttons/#msteams_webhooks.buttons.OpenURLButton","title":"<code>OpenURLButton</code>","text":"<p>         Bases: <code>Button</code></p> <p>Button that opens a URL when clicked or tapped.</p> Source code in <code>msteams_webhooks/buttons.py</code> <pre><code>class OpenURLButton(Button):\n\"\"\"Button that opens a URL when clicked or tapped.\"\"\"\n\n    def __init__(self, url: types.URL, title: str) -&gt; None:\n\"\"\"Open a URL.\n\n        Args:\n            url: URL to open.\n            title: Label that represents this button.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.title = title\n        self.url = url\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        return {\"type\": \"openUrl\", \"title\": self.title, \"value\": self.url}\n</code></pre>"},{"location":"reference/buttons/#msteams_webhooks.buttons.OpenURLButton.__init__","title":"<code>__init__(url, title)</code>","text":"<p>Open a URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>types.URL</code> <p>URL to open.</p> required <code>title</code> <code>str</code> <p>Label that represents this button.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/buttons.py</code> <pre><code>def __init__(self, url: types.URL, title: str) -&gt; None:\n\"\"\"Open a URL.\n\n    Args:\n        url: URL to open.\n        title: Label that represents this button.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.title = title\n    self.url = url\n</code></pre>"},{"location":"reference/buttons/#msteams_webhooks.buttons.OpenURLButton.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/buttons.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    return {\"type\": \"openUrl\", \"title\": self.title, \"value\": self.url}\n</code></pre>"},{"location":"reference/cards/","title":"Cards","text":"<p>Cards form the basis of all Teams messages.</p> <p>The type of card determines their format, and what elements may be included in them.</p>"},{"location":"reference/cards/#msteams_webhooks.cards.Card","title":"<code>Card</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Base card class.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>class Card(Entity):\n\"\"\"Base card class.\"\"\"\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.AdaptiveCard","title":"<code>AdaptiveCard</code>","text":"<p>         Bases: <code>Card</code></p> <p>Adaptive Cards are the most flexible type of card.</p> <p>They may contain any combination of text, images, and media, with optional formatting.</p> <p>Details: https://adaptivecards.io/ Schema Explorer: https://adaptivecards.io/explorer/AdaptiveCard.html</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>class AdaptiveCard(Card):\n\"\"\"Adaptive Cards are the most flexible type of card.\n\n    They may contain any combination of text, images, and media, with optional formatting.\n\n    Details: https://adaptivecards.io/\n    Schema Explorer: https://adaptivecards.io/explorer/AdaptiveCard.html\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        body: Optional[list[Union[CardElement, CardContainer]]] = None,\n        actions: Optional[list[Action]] = None,\n        version: Optional[str] = None,\n        background_image: Optional[types.URL] = None,\n        min_height: Optional[str] = None,\n        rtl: Optional[bool] = None,\n        speak: Optional[str] = None,\n        lang: Optional[str] = None,\n        vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n        schema: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"An Adaptive Card, containing a free-form body of card elements.\n\n        Args:\n            body: The card elements to show in the primary card region.\n            actions: The Actions to show in the card's action bar.\n            version: Schema version that this card requires. If a client is lower than\n                this version, the fallbackText will be rendered. NOTE: Version is not\n                required for cards within an ``Action.ShowCard``. However, it is required\n                for the top-level card.\n            background_image: Specifies the background image of the card.\n            min_height: Specifies the minimum height of the card.\n            rtl: When true content in this Adaptive Card should be presented right to left.\n                When ``False`` content in this Adaptive Card should be presented left to right.\n                If unset, the default platform behavior will apply.\n            speak: Specifies what should be spoken for this entire card. This is simple text or\n                SSML fragment.\n            lang: The 2-letter ISO-639-1 language used in the card. Used to localize any\n                date/time functions.\n            vertical_content_alignment: Defines how the content should be aligned vertically\n                within the container. Only relevant for fixed-height cards, or cards with a\n                `min_height` specified.\n            schema: Card schema URL.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.version = version or \"1.6\"\n        self.body = body or []\n        self.actions = actions or []\n        self.background_image = background_image\n        self.min_height = min_height\n        self.rtl = rtl\n        self.speak = speak\n        self.lang = lang\n        self.vertical_content_alignment = vertical_content_alignment\n        self.schema = schema or \"http://adaptivecards.io/schemas/adaptive-card.json\"\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload = {\n            \"contentType\": \"application/vnd.microsoft.card.adaptive\",\n            \"content\": {\n                \"$schema\": self.schema,\n                \"type\": \"AdaptiveCard\",\n                \"version\": self.version,\n            },\n        }\n        if self.body:\n            payload[\"content\"][\"body\"] = [x.serialize() for x in self.body]\n        if self.actions:\n            payload[\"content\"][\"actions\"] = [x.serialize() for x in self.actions]\n        if self.background_image:\n            payload[\"content\"][\"backgroundImage\"] = self.background_image\n        if self.min_height:\n            payload[\"content\"][\"minHeight\"] = self.min_height\n        if self.rtl is not None:\n            payload[\"content\"][\"rtl\"] = self.rtl\n        if self.speak:\n            payload[\"content\"][\"speak\"] = self.speak\n        if self.lang:\n            payload[\"content\"][\"lang\"] = self.lang\n        if self.vertical_content_alignment:\n            payload[\"content\"][\"verticalContentAlignment\"] = self.vertical_content_alignment\n        return payload\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.AdaptiveCard.__init__","title":"<code>__init__(*, body=None, actions=None, version=None, background_image=None, min_height=None, rtl=None, speak=None, lang=None, vertical_content_alignment=None, schema=None)</code>","text":"<p>An Adaptive Card, containing a free-form body of card elements.</p> <p>Parameters:</p> Name Type Description Default <code>body</code> <code>Optional[list[Union[CardElement, CardContainer]]]</code> <p>The card elements to show in the primary card region.</p> <code>None</code> <code>actions</code> <code>Optional[list[Action]]</code> <p>The Actions to show in the card's action bar.</p> <code>None</code> <code>version</code> <code>Optional[str]</code> <p>Schema version that this card requires. If a client is lower than this version, the fallbackText will be rendered. NOTE: Version is not required for cards within an <code>Action.ShowCard</code>. However, it is required for the top-level card.</p> <code>None</code> <code>background_image</code> <code>Optional[types.URL]</code> <p>Specifies the background image of the card.</p> <code>None</code> <code>min_height</code> <code>Optional[str]</code> <p>Specifies the minimum height of the card.</p> <code>None</code> <code>rtl</code> <code>Optional[bool]</code> <p>When true content in this Adaptive Card should be presented right to left. When <code>False</code> content in this Adaptive Card should be presented left to right. If unset, the default platform behavior will apply.</p> <code>None</code> <code>speak</code> <code>Optional[str]</code> <p>Specifies what should be spoken for this entire card. This is simple text or SSML fragment.</p> <code>None</code> <code>lang</code> <code>Optional[str]</code> <p>The 2-letter ISO-639-1 language used in the card. Used to localize any date/time functions.</p> <code>None</code> <code>vertical_content_alignment</code> <code>Optional[types.VerticalAlignmentTypes]</code> <p>Defines how the content should be aligned vertically within the container. Only relevant for fixed-height cards, or cards with a <code>min_height</code> specified.</p> <code>None</code> <code>schema</code> <code>Optional[str]</code> <p>Card schema URL.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>def __init__(\n    self,\n    *,\n    body: Optional[list[Union[CardElement, CardContainer]]] = None,\n    actions: Optional[list[Action]] = None,\n    version: Optional[str] = None,\n    background_image: Optional[types.URL] = None,\n    min_height: Optional[str] = None,\n    rtl: Optional[bool] = None,\n    speak: Optional[str] = None,\n    lang: Optional[str] = None,\n    vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n    schema: Optional[str] = None,\n) -&gt; None:\n\"\"\"An Adaptive Card, containing a free-form body of card elements.\n\n    Args:\n        body: The card elements to show in the primary card region.\n        actions: The Actions to show in the card's action bar.\n        version: Schema version that this card requires. If a client is lower than\n            this version, the fallbackText will be rendered. NOTE: Version is not\n            required for cards within an ``Action.ShowCard``. However, it is required\n            for the top-level card.\n        background_image: Specifies the background image of the card.\n        min_height: Specifies the minimum height of the card.\n        rtl: When true content in this Adaptive Card should be presented right to left.\n            When ``False`` content in this Adaptive Card should be presented left to right.\n            If unset, the default platform behavior will apply.\n        speak: Specifies what should be spoken for this entire card. This is simple text or\n            SSML fragment.\n        lang: The 2-letter ISO-639-1 language used in the card. Used to localize any\n            date/time functions.\n        vertical_content_alignment: Defines how the content should be aligned vertically\n            within the container. Only relevant for fixed-height cards, or cards with a\n            `min_height` specified.\n        schema: Card schema URL.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.version = version or \"1.6\"\n    self.body = body or []\n    self.actions = actions or []\n    self.background_image = background_image\n    self.min_height = min_height\n    self.rtl = rtl\n    self.speak = speak\n    self.lang = lang\n    self.vertical_content_alignment = vertical_content_alignment\n    self.schema = schema or \"http://adaptivecards.io/schemas/adaptive-card.json\"\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.AdaptiveCard.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload = {\n        \"contentType\": \"application/vnd.microsoft.card.adaptive\",\n        \"content\": {\n            \"$schema\": self.schema,\n            \"type\": \"AdaptiveCard\",\n            \"version\": self.version,\n        },\n    }\n    if self.body:\n        payload[\"content\"][\"body\"] = [x.serialize() for x in self.body]\n    if self.actions:\n        payload[\"content\"][\"actions\"] = [x.serialize() for x in self.actions]\n    if self.background_image:\n        payload[\"content\"][\"backgroundImage\"] = self.background_image\n    if self.min_height:\n        payload[\"content\"][\"minHeight\"] = self.min_height\n    if self.rtl is not None:\n        payload[\"content\"][\"rtl\"] = self.rtl\n    if self.speak:\n        payload[\"content\"][\"speak\"] = self.speak\n    if self.lang:\n        payload[\"content\"][\"lang\"] = self.lang\n    if self.vertical_content_alignment:\n        payload[\"content\"][\"verticalContentAlignment\"] = self.vertical_content_alignment\n    return payload\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.HeroCard","title":"<code>HeroCard</code>","text":"<p>         Bases: <code>Card</code></p> <p>Hero Card.</p> <p>A card that typically contains a single large image, one or more buttons, and text.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>class HeroCard(Card):\n\"\"\"Hero Card.\n\n    A card that typically contains a single large image, one or more buttons, and text.\n    \"\"\"\n\n    def __init__(\n        self,\n        title: str,\n        text: str,\n        *,\n        subtitle: Optional[str] = None,\n        images: Optional[list[types.URL]] = None,\n        buttons: Optional[list[Button]] = None,\n    ) -&gt; None:\n\"\"\"Display a single large image, one or more buttons, and text.\n\n        Args:\n            title: Main text to display.\n            text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n            subtitle: Sub-title to display under `title`.\n            images: List of image URLs to display.\n            buttons: List of buttons to include in the card.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.title = title\n        self.text = text\n        self.subtitle = subtitle\n        self.images = images\n        self.buttons = buttons\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\n            \"contentType\": \"application/vnd.microsoft.card.hero\",\n            \"content\": {},\n        }\n        payload[\"content\"][\"title\"] = self.title\n        payload[\"content\"][\"text\"] = self.text\n        if self.subtitle:\n            payload[\"content\"][\"subtitle\"] = self.subtitle\n        if self.images:\n            payload[\"content\"][\"images\"] = [{\"url\": img} for img in self.images]\n        if self.buttons:\n            payload[\"content\"][\"buttons\"] = [x.serialize() for x in self.buttons]\n        return payload\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.HeroCard.__init__","title":"<code>__init__(title, text, *, subtitle=None, images=None, buttons=None)</code>","text":"<p>Display a single large image, one or more buttons, and text.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Main text to display.</p> required <code>text</code> <code>str</code> <p>Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)</p> required <code>subtitle</code> <code>Optional[str]</code> <p>Sub-title to display under <code>title</code>.</p> <code>None</code> <code>images</code> <code>Optional[list[types.URL]]</code> <p>List of image URLs to display.</p> <code>None</code> <code>buttons</code> <code>Optional[list[Button]]</code> <p>List of buttons to include in the card.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>def __init__(\n    self,\n    title: str,\n    text: str,\n    *,\n    subtitle: Optional[str] = None,\n    images: Optional[list[types.URL]] = None,\n    buttons: Optional[list[Button]] = None,\n) -&gt; None:\n\"\"\"Display a single large image, one or more buttons, and text.\n\n    Args:\n        title: Main text to display.\n        text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n        subtitle: Sub-title to display under `title`.\n        images: List of image URLs to display.\n        buttons: List of buttons to include in the card.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.title = title\n    self.text = text\n    self.subtitle = subtitle\n    self.images = images\n    self.buttons = buttons\n</code></pre>"},{"location":"reference/cards/#msteams_webhooks.cards.HeroCard.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/cards.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\n        \"contentType\": \"application/vnd.microsoft.card.hero\",\n        \"content\": {},\n    }\n    payload[\"content\"][\"title\"] = self.title\n    payload[\"content\"][\"text\"] = self.text\n    if self.subtitle:\n        payload[\"content\"][\"subtitle\"] = self.subtitle\n    if self.images:\n        payload[\"content\"][\"images\"] = [{\"url\": img} for img in self.images]\n    if self.buttons:\n        payload[\"content\"][\"buttons\"] = [x.serialize() for x in self.buttons]\n    return payload\n</code></pre>"},{"location":"reference/containers/","title":"Containers","text":"<p>Containers provide ways to organize and format elements within cards.</p>"},{"location":"reference/containers/#msteams_webhooks.containers.CardContainer","title":"<code>CardContainer</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Base container class.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class CardContainer(Entity):\n\"\"\"Base container class.\"\"\"\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ActionSet","title":"<code>ActionSet</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Action sets.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/ActionSet.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class ActionSet(CardContainer):\n\"\"\"Action sets.\n\n    Schema Explorer: https://adaptivecards.io/explorer/ActionSet.html\n    \"\"\"\n\n    def __init__(self, actions: list[Action]) -&gt; None:\n\"\"\"Displays a set of actions.\n\n        Args:\n            actions: List of ``Action`` elements to show.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.actions = actions\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        return {\"type\": \"ActionSet\", \"actions\": [x.serialize() for x in self.actions]}\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ActionSet.__init__","title":"<code>__init__(actions)</code>","text":"<p>Displays a set of actions.</p> <p>Parameters:</p> Name Type Description Default <code>actions</code> <code>list[Action]</code> <p>List of <code>Action</code> elements to show.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(self, actions: list[Action]) -&gt; None:\n\"\"\"Displays a set of actions.\n\n    Args:\n        actions: List of ``Action`` elements to show.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.actions = actions\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ActionSet.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    return {\"type\": \"ActionSet\", \"actions\": [x.serialize() for x in self.actions]}\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Container","title":"<code>Container</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Generic container, which may contain any other container or element.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Container.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class Container(CardContainer):\n\"\"\"Generic container, which may contain any other container or element.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Container.html\n    \"\"\"\n\n    def __init__(\n        self,\n        items: list[Union[CardElement, CardContainer]],\n        *,\n        select_action: Optional[Action] = None,\n        style: Optional[types.ContainerStyleTypes] = None,\n        vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n        bleed: Optional[bool] = None,\n        background_image: Optional[types.URL] = None,\n        min_height: Optional[str] = None,\n        rtl: Optional[bool] = None,\n    ) -&gt; None:\n\"\"\"Containers group items together in arbitrary ways.\n\n        May be combined with other containers or elements in flexible ways.\n\n        Args:\n            items: The card elements to render inside the ``Container``.\n            select_action: An ``Action`` that will be invoked when the ``Container`` is\n                tapped or selected. Action.ShowCard is not supported.\n            style: Style hint for ``Container``.\n            vertical_content_alignment: Defines how the content should be aligned\n                vertically within the container. When not specified, the value of\n                vertical_content_alignment is inherited from the parent container. If no\n                parent container has verticalContentAlignment set, it defaults to Top.\n            bleed: Determines whether the element should bleed through its parent`s padding.\n            background_image: Specifies the background image. Acceptable formats are PNG,\n                JPEG, and GIF.\n            min_height: Specifies the minimum height of the container in pixels, like \"80px\".\n            rtl: When true content in this container should be presented right to left. When\n                'false' content in this container should be presented left to right. When unset\n                layout direction will inherit from parent container or column. If unset in all\n                ancestors, the default platform behavior will apply.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.items = items\n        self.select_action = select_action\n        self.style = style\n        self.vertical_content_alignment = vertical_content_alignment\n        self.bleed = bleed\n        self.background_image = background_image\n        self.min_height = min_height\n        self.rtl = rtl\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload = {\n            \"type\": \"Container\",\n            \"items\": [x.serialize() for x in self.items],\n        }\n        if self.select_action:\n            payload[\"selectAction\"] = self.select_action.serialize()\n        if self.style:\n            payload[\"style\"] = self.style\n        if self.vertical_content_alignment:\n            payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n        if self.bleed is not None:\n            payload[\"bleed\"] = self.bleed\n        if self.background_image:\n            payload[\"backgroundImage\"] = self.background_image\n        if self.min_height:\n            payload[\"minHeight\"] = self.min_height\n        if self.rtl is not None:\n            payload[\"rtl\"] = self.rtl\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Container.__init__","title":"<code>__init__(items, *, select_action=None, style=None, vertical_content_alignment=None, bleed=None, background_image=None, min_height=None, rtl=None)</code>","text":"<p>Containers group items together in arbitrary ways.</p> <p>May be combined with other containers or elements in flexible ways.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[Union[CardElement, CardContainer]]</code> <p>The card elements to render inside the <code>Container</code>.</p> required <code>select_action</code> <code>Optional[Action]</code> <p>An <code>Action</code> that will be invoked when the <code>Container</code> is tapped or selected. Action.ShowCard is not supported.</p> <code>None</code> <code>style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Style hint for <code>Container</code>.</p> <code>None</code> <code>vertical_content_alignment</code> <code>Optional[types.VerticalAlignmentTypes]</code> <p>Defines how the content should be aligned vertically within the container. When not specified, the value of vertical_content_alignment is inherited from the parent container. If no parent container has verticalContentAlignment set, it defaults to Top.</p> <code>None</code> <code>bleed</code> <code>Optional[bool]</code> <p>Determines whether the element should bleed through its parent`s padding.</p> <code>None</code> <code>background_image</code> <code>Optional[types.URL]</code> <p>Specifies the background image. Acceptable formats are PNG, JPEG, and GIF.</p> <code>None</code> <code>min_height</code> <code>Optional[str]</code> <p>Specifies the minimum height of the container in pixels, like \"80px\".</p> <code>None</code> <code>rtl</code> <code>Optional[bool]</code> <p>When true content in this container should be presented right to left. When 'false' content in this container should be presented left to right. When unset layout direction will inherit from parent container or column. If unset in all ancestors, the default platform behavior will apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    items: list[Union[CardElement, CardContainer]],\n    *,\n    select_action: Optional[Action] = None,\n    style: Optional[types.ContainerStyleTypes] = None,\n    vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n    bleed: Optional[bool] = None,\n    background_image: Optional[types.URL] = None,\n    min_height: Optional[str] = None,\n    rtl: Optional[bool] = None,\n) -&gt; None:\n\"\"\"Containers group items together in arbitrary ways.\n\n    May be combined with other containers or elements in flexible ways.\n\n    Args:\n        items: The card elements to render inside the ``Container``.\n        select_action: An ``Action`` that will be invoked when the ``Container`` is\n            tapped or selected. Action.ShowCard is not supported.\n        style: Style hint for ``Container``.\n        vertical_content_alignment: Defines how the content should be aligned\n            vertically within the container. When not specified, the value of\n            vertical_content_alignment is inherited from the parent container. If no\n            parent container has verticalContentAlignment set, it defaults to Top.\n        bleed: Determines whether the element should bleed through its parent`s padding.\n        background_image: Specifies the background image. Acceptable formats are PNG,\n            JPEG, and GIF.\n        min_height: Specifies the minimum height of the container in pixels, like \"80px\".\n        rtl: When true content in this container should be presented right to left. When\n            'false' content in this container should be presented left to right. When unset\n            layout direction will inherit from parent container or column. If unset in all\n            ancestors, the default platform behavior will apply.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.items = items\n    self.select_action = select_action\n    self.style = style\n    self.vertical_content_alignment = vertical_content_alignment\n    self.bleed = bleed\n    self.background_image = background_image\n    self.min_height = min_height\n    self.rtl = rtl\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Container.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload = {\n        \"type\": \"Container\",\n        \"items\": [x.serialize() for x in self.items],\n    }\n    if self.select_action:\n        payload[\"selectAction\"] = self.select_action.serialize()\n    if self.style:\n        payload[\"style\"] = self.style\n    if self.vertical_content_alignment:\n        payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n    if self.bleed is not None:\n        payload[\"bleed\"] = self.bleed\n    if self.background_image:\n        payload[\"backgroundImage\"] = self.background_image\n    if self.min_height:\n        payload[\"minHeight\"] = self.min_height\n    if self.rtl is not None:\n        payload[\"rtl\"] = self.rtl\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Column","title":"<code>Column</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>A single column, as an lement of a <code>ColumnSet</code>, or a column in a <code>Table</code>.</p> <p>Schema explorer: https://adaptivecards.io/explorer/Column.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class Column(CardContainer):\n\"\"\"A single column, as an lement of a ``ColumnSet``, or a column in a ``Table``.\n\n    Schema explorer: https://adaptivecards.io/explorer/Column.html\n    \"\"\"\n\n    def __init__(\n        self,\n        items: Optional[list[CardElement]] = None,\n        background_image: Optional[types.URL] = None,\n        bleed: Optional[bool] = None,\n        min_height: Optional[str] = None,\n        rtl: Optional[bool] = None,\n        separator: Optional[bool] = None,\n        spacing: Optional[types.SpacingTypes] = None,\n        select_action: Optional[Action] = None,\n        style: Optional[types.ContainerStyleTypes] = None,\n        vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n        width: Optional[types.ColumnWidthTypes] = None,\n    ) -&gt; None:\n\"\"\"Defines a container that is part of a ``ColumnSet`` or a column in a ``Table``.\n\n        Args:\n            items: The card elements to render inside the ``Column``.\n            background_image: Specifies the background image. Acceptable formats are\n                PNG, JPEG, and GIF.\n            bleed: Determines whether the column should bleed through its parent`s padding.\n            min_height: Specifies the minimum height of the column in pixels, like \"80px\".\n            rtl: When true content in this column should be presented right to left. When\n                ``False`` content in this column should be presented left to right. When\n                unset layout direction will inherit from parent container or column. If unset\n                in all ancestors, the default platform behavior will apply.\n            separator: When ``True``, draw a separating line between this column and the previous\n                column.\n            spacing: Controls the amount of spacing between this column and the preceding column.\n            select_action: An ``Action`` that will be invoked when the ``Column`` is tapped or\n                selected. Action.ShowCard is not supported.\n            style: Style hint for ``Column``.\n            vertical_content_alignment: Defines how the content should be aligned vertically within\n                the column. When not specified, the value of verticalContentAlignment is inherited\n                from the parent container. If no parent container has verticalContentAlignment set,\n                it defaults to Top.\n            width: \"auto\", \"stretch\", a number representing relative width of the column in the\n                column group, or in version 1.1 and higher, a specific pixel width, like \"50px\".\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.items = items\n        self.background_image = background_image\n        self.bleed = bleed\n        self.min_height = min_height\n        self.rtl = rtl\n        self.separator = separator\n        self.spacing = spacing\n        self.select_action = select_action\n        self.style = style\n        self.vertical_content_alignment = vertical_content_alignment\n        self.width = width\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\"type\": \"Column\"}\n        if self.items:\n            payload[\"items\"] = [x.serialize() for x in self.items]\n        if self.background_image:\n            payload[\"backgroundImage\"] = self.background_image\n        if self.bleed is not None:\n            payload[\"bleed\"] = self.bleed\n        if self.min_height:\n            payload[\"minHeight\"] = self.min_height\n        if self.rtl is not None:\n            payload[\"rtl\"] = self.rtl\n        if self.separator is not None:\n            payload[\"separator\"] = self.separator\n        if self.spacing:\n            payload[\"spacing\"] = self.spacing\n        if self.select_action:\n            payload[\"selectAction\"] = self.select_action.serialize()\n        if self.style:\n            payload[\"style\"] = self.style\n        if self.vertical_content_alignment:\n            payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n        if self.width:\n            payload[\"width\"] = self.width\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Column.__init__","title":"<code>__init__(items=None, background_image=None, bleed=None, min_height=None, rtl=None, separator=None, spacing=None, select_action=None, style=None, vertical_content_alignment=None, width=None)</code>","text":"<p>Defines a container that is part of a <code>ColumnSet</code> or a column in a <code>Table</code>.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>Optional[list[CardElement]]</code> <p>The card elements to render inside the <code>Column</code>.</p> <code>None</code> <code>background_image</code> <code>Optional[types.URL]</code> <p>Specifies the background image. Acceptable formats are PNG, JPEG, and GIF.</p> <code>None</code> <code>bleed</code> <code>Optional[bool]</code> <p>Determines whether the column should bleed through its parent`s padding.</p> <code>None</code> <code>min_height</code> <code>Optional[str]</code> <p>Specifies the minimum height of the column in pixels, like \"80px\".</p> <code>None</code> <code>rtl</code> <code>Optional[bool]</code> <p>When true content in this column should be presented right to left. When <code>False</code> content in this column should be presented left to right. When unset layout direction will inherit from parent container or column. If unset in all ancestors, the default platform behavior will apply.</p> <code>None</code> <code>separator</code> <code>Optional[bool]</code> <p>When <code>True</code>, draw a separating line between this column and the previous column.</p> <code>None</code> <code>spacing</code> <code>Optional[types.SpacingTypes]</code> <p>Controls the amount of spacing between this column and the preceding column.</p> <code>None</code> <code>select_action</code> <code>Optional[Action]</code> <p>An <code>Action</code> that will be invoked when the <code>Column</code> is tapped or selected. Action.ShowCard is not supported.</p> <code>None</code> <code>style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Style hint for <code>Column</code>.</p> <code>None</code> <code>vertical_content_alignment</code> <code>Optional[types.VerticalAlignmentTypes]</code> <p>Defines how the content should be aligned vertically within the column. When not specified, the value of verticalContentAlignment is inherited from the parent container. If no parent container has verticalContentAlignment set, it defaults to Top.</p> <code>None</code> <code>width</code> <code>Optional[types.ColumnWidthTypes]</code> <p>\"auto\", \"stretch\", a number representing relative width of the column in the column group, or in version 1.1 and higher, a specific pixel width, like \"50px\".</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    items: Optional[list[CardElement]] = None,\n    background_image: Optional[types.URL] = None,\n    bleed: Optional[bool] = None,\n    min_height: Optional[str] = None,\n    rtl: Optional[bool] = None,\n    separator: Optional[bool] = None,\n    spacing: Optional[types.SpacingTypes] = None,\n    select_action: Optional[Action] = None,\n    style: Optional[types.ContainerStyleTypes] = None,\n    vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n    width: Optional[types.ColumnWidthTypes] = None,\n) -&gt; None:\n\"\"\"Defines a container that is part of a ``ColumnSet`` or a column in a ``Table``.\n\n    Args:\n        items: The card elements to render inside the ``Column``.\n        background_image: Specifies the background image. Acceptable formats are\n            PNG, JPEG, and GIF.\n        bleed: Determines whether the column should bleed through its parent`s padding.\n        min_height: Specifies the minimum height of the column in pixels, like \"80px\".\n        rtl: When true content in this column should be presented right to left. When\n            ``False`` content in this column should be presented left to right. When\n            unset layout direction will inherit from parent container or column. If unset\n            in all ancestors, the default platform behavior will apply.\n        separator: When ``True``, draw a separating line between this column and the previous\n            column.\n        spacing: Controls the amount of spacing between this column and the preceding column.\n        select_action: An ``Action`` that will be invoked when the ``Column`` is tapped or\n            selected. Action.ShowCard is not supported.\n        style: Style hint for ``Column``.\n        vertical_content_alignment: Defines how the content should be aligned vertically within\n            the column. When not specified, the value of verticalContentAlignment is inherited\n            from the parent container. If no parent container has verticalContentAlignment set,\n            it defaults to Top.\n        width: \"auto\", \"stretch\", a number representing relative width of the column in the\n            column group, or in version 1.1 and higher, a specific pixel width, like \"50px\".\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.items = items\n    self.background_image = background_image\n    self.bleed = bleed\n    self.min_height = min_height\n    self.rtl = rtl\n    self.separator = separator\n    self.spacing = spacing\n    self.select_action = select_action\n    self.style = style\n    self.vertical_content_alignment = vertical_content_alignment\n    self.width = width\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Column.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\"type\": \"Column\"}\n    if self.items:\n        payload[\"items\"] = [x.serialize() for x in self.items]\n    if self.background_image:\n        payload[\"backgroundImage\"] = self.background_image\n    if self.bleed is not None:\n        payload[\"bleed\"] = self.bleed\n    if self.min_height:\n        payload[\"minHeight\"] = self.min_height\n    if self.rtl is not None:\n        payload[\"rtl\"] = self.rtl\n    if self.separator is not None:\n        payload[\"separator\"] = self.separator\n    if self.spacing:\n        payload[\"spacing\"] = self.spacing\n    if self.select_action:\n        payload[\"selectAction\"] = self.select_action.serialize()\n    if self.style:\n        payload[\"style\"] = self.style\n    if self.vertical_content_alignment:\n        payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n    if self.width:\n        payload[\"width\"] = self.width\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ColumnSet","title":"<code>ColumnSet</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Grouping of columns.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/ColumnSet.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class ColumnSet(CardContainer):\n\"\"\"Grouping of columns.\n\n    Schema Explorer: https://adaptivecards.io/explorer/ColumnSet.html\n    \"\"\"\n\n    def __init__(\n        self,\n        columns: Optional[list[Column]] = None,\n        select_action: Optional[Action] = None,\n        style: Optional[types.ContainerStyleTypes] = None,\n        bleed: Optional[bool] = None,\n        min_height: Optional[str] = None,\n        horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n    ) -&gt; None:\n\"\"\"``ColumnSet`` divides a region into ``Columns``, allowing elements to sit side-by-side.\n\n        Args:\n            columns: The list of ``Columns`` to divide the region into.\n            select_action: \tAn ``Action`` that will be invoked when the ColumnSet is tapped\n                or selected. Action.ShowCard is not supported.\n            style: Style hint for ``ColumnSet``.\n            bleed: Determines whether the element should bleed through its parent's padding.\n            min_height: Specifies the minimum height of the column set in pixels, like \"80px\".\n            horizontal_alignment: Controls the horizontal alignment of the ColumnSet. When not\n                specified, the value of horizontalAlignment is inherited from the parent container.\n                If no parent container has horizontalAlignment set, it defaults to Left.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.columns = columns\n        self.select_action = select_action\n        self.style = style\n        self.bleed = bleed\n        self.min_height = min_height\n        self.horizontal_alignment = horizontal_alignment\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\"type\": \"ColumnSet\"}\n        if self.columns:\n            payload[\"columns\"] = [x.serialize() for x in self.columns]\n        if self.select_action:\n            payload[\"selectAction\"] = self.select_action.serialize()\n        if self.style:\n            payload[\"style\"] = self.style\n        if self.bleed is not None:\n            payload[\"bleed\"] = self.bleed\n        if self.min_height:\n            payload[\"minHeight\"] = self.min_height\n        if self.horizontal_alignment:\n            payload[\"horizontalAlignment\"] = self.horizontal_alignment\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ColumnSet.__init__","title":"<code>__init__(columns=None, select_action=None, style=None, bleed=None, min_height=None, horizontal_alignment=None)</code>","text":"<p><code>ColumnSet</code> divides a region into <code>Columns</code>, allowing elements to sit side-by-side.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[list[Column]]</code> <p>The list of <code>Columns</code> to divide the region into.</p> <code>None</code> <code>select_action</code> <code>Optional[Action]</code> <p>An <code>Action</code> that will be invoked when the ColumnSet is tapped or selected. Action.ShowCard is not supported.</p> <code>None</code> <code>style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Style hint for <code>ColumnSet</code>.</p> <code>None</code> <code>bleed</code> <code>Optional[bool]</code> <p>Determines whether the element should bleed through its parent's padding.</p> <code>None</code> <code>min_height</code> <code>Optional[str]</code> <p>Specifies the minimum height of the column set in pixels, like \"80px\".</p> <code>None</code> <code>horizontal_alignment</code> <code>Optional[types.HorizontalAlignmentTypes]</code> <p>Controls the horizontal alignment of the ColumnSet. When not specified, the value of horizontalAlignment is inherited from the parent container. If no parent container has horizontalAlignment set, it defaults to Left.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    columns: Optional[list[Column]] = None,\n    select_action: Optional[Action] = None,\n    style: Optional[types.ContainerStyleTypes] = None,\n    bleed: Optional[bool] = None,\n    min_height: Optional[str] = None,\n    horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n) -&gt; None:\n\"\"\"``ColumnSet`` divides a region into ``Columns``, allowing elements to sit side-by-side.\n\n    Args:\n        columns: The list of ``Columns`` to divide the region into.\n        select_action: \tAn ``Action`` that will be invoked when the ColumnSet is tapped\n            or selected. Action.ShowCard is not supported.\n        style: Style hint for ``ColumnSet``.\n        bleed: Determines whether the element should bleed through its parent's padding.\n        min_height: Specifies the minimum height of the column set in pixels, like \"80px\".\n        horizontal_alignment: Controls the horizontal alignment of the ColumnSet. When not\n            specified, the value of horizontalAlignment is inherited from the parent container.\n            If no parent container has horizontalAlignment set, it defaults to Left.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.columns = columns\n    self.select_action = select_action\n    self.style = style\n    self.bleed = bleed\n    self.min_height = min_height\n    self.horizontal_alignment = horizontal_alignment\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ColumnSet.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\"type\": \"ColumnSet\"}\n    if self.columns:\n        payload[\"columns\"] = [x.serialize() for x in self.columns]\n    if self.select_action:\n        payload[\"selectAction\"] = self.select_action.serialize()\n    if self.style:\n        payload[\"style\"] = self.style\n    if self.bleed is not None:\n        payload[\"bleed\"] = self.bleed\n    if self.min_height:\n        payload[\"minHeight\"] = self.min_height\n    if self.horizontal_alignment:\n        payload[\"horizontalAlignment\"] = self.horizontal_alignment\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Fact","title":"<code>Fact</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Facts organize key/value pairs into an organized list.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Fact.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class Fact(CardContainer):\n\"\"\"Facts organize key/value pairs into an organized list.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Fact.html\n    \"\"\"\n\n    def __init__(self, title: str, value: str) -&gt; None:\n\"\"\"Describes a Fact in a FactSet as a key/value pair.\n\n        Args:\n            title: The title of the fact.\n            value: The value of the fact.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.title = title\n        self.value = value\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        return {\"title\": self.title, \"value\": self.value}\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Fact.__init__","title":"<code>__init__(title, value)</code>","text":"<p>Describes a Fact in a FactSet as a key/value pair.</p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>The title of the fact.</p> required <code>value</code> <code>str</code> <p>The value of the fact.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(self, title: str, value: str) -&gt; None:\n\"\"\"Describes a Fact in a FactSet as a key/value pair.\n\n    Args:\n        title: The title of the fact.\n        value: The value of the fact.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.title = title\n    self.value = value\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Fact.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    return {\"title\": self.title, \"value\": self.value}\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.FactSet","title":"<code>FactSet</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>A group of <code>Fact</code> containers.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/FactSet.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class FactSet(CardContainer):\n\"\"\"A group of ``Fact`` containers.\n\n    Schema Explorer: https://adaptivecards.io/explorer/FactSet.html\n    \"\"\"\n\n    def __init__(self, facts: list[Fact]) -&gt; None:\n\"\"\"Displays a series of facts (i.e. name/value pairs) in a tabular form.\n\n        Args:\n            facts: The list of ``Fact`` elements to show.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.facts = facts\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        return {\n            \"type\": \"FactSet\",\n            \"facts\": [x.serialize() for x in self.facts],\n        }\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.FactSet.__init__","title":"<code>__init__(facts)</code>","text":"<p>Displays a series of facts (i.e. name/value pairs) in a tabular form.</p> <p>Parameters:</p> Name Type Description Default <code>facts</code> <code>list[Fact]</code> <p>The list of <code>Fact</code> elements to show.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(self, facts: list[Fact]) -&gt; None:\n\"\"\"Displays a series of facts (i.e. name/value pairs) in a tabular form.\n\n    Args:\n        facts: The list of ``Fact`` elements to show.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.facts = facts\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.FactSet.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    return {\n        \"type\": \"FactSet\",\n        \"facts\": [x.serialize() for x in self.facts],\n    }\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ImageSet","title":"<code>ImageSet</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>A collection of images.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/ImageSet.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class ImageSet(CardContainer):\n\"\"\"A collection of images.\n\n    Schema Explorer: https://adaptivecards.io/explorer/ImageSet.html\n    \"\"\"\n\n    def __init__(\n        self,\n        images: list[Image],\n        *,\n        image_size: Optional[types.ImageSizeTypes] = None,\n    ) -&gt; None:\n\"\"\"Displays a collection of Images similar to a gallery.\n\n        Acceptable formats are PNG, JPEG, and GIF.\n\n        Args:\n            images: The list of ``Image`` elements to show.\n            image_size: Controls the approximate size of each image. The physical\n                dimensions will vary per host. Auto and stretch are not supported for\n                ImageSet. The size will default to medium if those values are set.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.images = images\n        self.image_size = image_size\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload = {\n            \"type\": \"ImageSet\",\n            \"images\": [x.serialize() for x in self.images],\n        }\n        if self.image_size:\n            payload[\"imageSize\"] = self.image_size\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ImageSet.__init__","title":"<code>__init__(images, *, image_size=None)</code>","text":"<p>Displays a collection of Images similar to a gallery.</p> <p>Acceptable formats are PNG, JPEG, and GIF.</p> <p>Parameters:</p> Name Type Description Default <code>images</code> <code>list[Image]</code> <p>The list of <code>Image</code> elements to show.</p> required <code>image_size</code> <code>Optional[types.ImageSizeTypes]</code> <p>Controls the approximate size of each image. The physical dimensions will vary per host. Auto and stretch are not supported for ImageSet. The size will default to medium if those values are set.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    images: list[Image],\n    *,\n    image_size: Optional[types.ImageSizeTypes] = None,\n) -&gt; None:\n\"\"\"Displays a collection of Images similar to a gallery.\n\n    Acceptable formats are PNG, JPEG, and GIF.\n\n    Args:\n        images: The list of ``Image`` elements to show.\n        image_size: Controls the approximate size of each image. The physical\n            dimensions will vary per host. Auto and stretch are not supported for\n            ImageSet. The size will default to medium if those values are set.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.images = images\n    self.image_size = image_size\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.ImageSet.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload = {\n        \"type\": \"ImageSet\",\n        \"images\": [x.serialize() for x in self.images],\n    }\n    if self.image_size:\n        payload[\"imageSize\"] = self.image_size\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableCell","title":"<code>TableCell</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Single cell of a <code>Table</code> container.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/TableCell.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class TableCell(CardContainer):\n\"\"\"Single cell of a ``Table`` container.\n\n    Schema Explorer: https://adaptivecards.io/explorer/TableCell.html\n    \"\"\"\n\n    def __init__(\n        self,\n        items: list[CardElement],\n        *,\n        select_action: Optional[Action] = None,\n        style: Optional[types.ContainerStyleTypes] = None,\n        vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n        bleed: Optional[bool] = None,\n        background_image: Optional[types.URL] = None,\n        min_height: Optional[str] = None,\n        rtl: Optional[bool] = None,\n    ) -&gt; None:\n\"\"\"Represents a cell within a row of a ``Table`` element.\n\n        Args:\n            items: The card elements to render inside the ``TableCell``.\n            select_action: An Action that will be invoked when the ``TableCell`` is tapped\n                or selected. Action.ShowCard is not supported.\n            style: Style hint for ``TableCell``.\n            vertical_content_alignment: Defines how the content should be aligned vertically\n                within the container. When not specified, the value of vertical_content_alignment\n                is inherited from the parent container. If no parent container has\n                vertical_content_alignment set, it defaults to Top.\n            bleed: Determines whether the element should bleed through its parent's padding.\n            background_image: Specifies the background image. Acceptable formats are PNG, JPEG,\n                and GIF.\n            min_height: Specifies the minimum height of the container in pixels, like \"80px\".\n            rtl: When true content in this container should be presented right to left. When 'false'\n                content in this container should be presented left to right. When unset layout\n                direction will inherit from parent container or column. If unset in all ancestors,\n                the default platform behavior will apply.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.items = items\n        self.select_action = select_action\n        self.style = style\n        self.vertical_content_alignment = vertical_content_alignment\n        self.bleed = bleed\n        self.background_image = background_image\n        self.min_height = min_height\n        self.rtl = rtl\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload = {\n            \"type\": \"TableCell\",\n            \"items\": [x.serialize() for x in self.items],\n        }\n        if self.select_action:\n            payload[\"selectAction\"] = self.select_action.serialize()\n        if self.style:\n            payload[\"style\"] = self.style\n        if self.vertical_content_alignment:\n            payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n        if self.bleed is not None:\n            payload[\"bleed\"] = self.bleed\n        if self.background_image:\n            payload[\"backgroundImage\"] = self.background_image\n        if self.min_height:\n            payload[\"minHeight\"] = self.min_height\n        if self.rtl is not None:\n            payload[\"rtl\"] = self.rtl\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableCell.__init__","title":"<code>__init__(items, *, select_action=None, style=None, vertical_content_alignment=None, bleed=None, background_image=None, min_height=None, rtl=None)</code>","text":"<p>Represents a cell within a row of a <code>Table</code> element.</p> <p>Parameters:</p> Name Type Description Default <code>items</code> <code>list[CardElement]</code> <p>The card elements to render inside the <code>TableCell</code>.</p> required <code>select_action</code> <code>Optional[Action]</code> <p>An Action that will be invoked when the <code>TableCell</code> is tapped or selected. Action.ShowCard is not supported.</p> <code>None</code> <code>style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Style hint for <code>TableCell</code>.</p> <code>None</code> <code>vertical_content_alignment</code> <code>Optional[types.VerticalAlignmentTypes]</code> <p>Defines how the content should be aligned vertically within the container. When not specified, the value of vertical_content_alignment is inherited from the parent container. If no parent container has vertical_content_alignment set, it defaults to Top.</p> <code>None</code> <code>bleed</code> <code>Optional[bool]</code> <p>Determines whether the element should bleed through its parent's padding.</p> <code>None</code> <code>background_image</code> <code>Optional[types.URL]</code> <p>Specifies the background image. Acceptable formats are PNG, JPEG, and GIF.</p> <code>None</code> <code>min_height</code> <code>Optional[str]</code> <p>Specifies the minimum height of the container in pixels, like \"80px\".</p> <code>None</code> <code>rtl</code> <code>Optional[bool]</code> <p>When true content in this container should be presented right to left. When 'false' content in this container should be presented left to right. When unset layout direction will inherit from parent container or column. If unset in all ancestors, the default platform behavior will apply.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    items: list[CardElement],\n    *,\n    select_action: Optional[Action] = None,\n    style: Optional[types.ContainerStyleTypes] = None,\n    vertical_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n    bleed: Optional[bool] = None,\n    background_image: Optional[types.URL] = None,\n    min_height: Optional[str] = None,\n    rtl: Optional[bool] = None,\n) -&gt; None:\n\"\"\"Represents a cell within a row of a ``Table`` element.\n\n    Args:\n        items: The card elements to render inside the ``TableCell``.\n        select_action: An Action that will be invoked when the ``TableCell`` is tapped\n            or selected. Action.ShowCard is not supported.\n        style: Style hint for ``TableCell``.\n        vertical_content_alignment: Defines how the content should be aligned vertically\n            within the container. When not specified, the value of vertical_content_alignment\n            is inherited from the parent container. If no parent container has\n            vertical_content_alignment set, it defaults to Top.\n        bleed: Determines whether the element should bleed through its parent's padding.\n        background_image: Specifies the background image. Acceptable formats are PNG, JPEG,\n            and GIF.\n        min_height: Specifies the minimum height of the container in pixels, like \"80px\".\n        rtl: When true content in this container should be presented right to left. When 'false'\n            content in this container should be presented left to right. When unset layout\n            direction will inherit from parent container or column. If unset in all ancestors,\n            the default platform behavior will apply.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.items = items\n    self.select_action = select_action\n    self.style = style\n    self.vertical_content_alignment = vertical_content_alignment\n    self.bleed = bleed\n    self.background_image = background_image\n    self.min_height = min_height\n    self.rtl = rtl\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableCell.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload = {\n        \"type\": \"TableCell\",\n        \"items\": [x.serialize() for x in self.items],\n    }\n    if self.select_action:\n        payload[\"selectAction\"] = self.select_action.serialize()\n    if self.style:\n        payload[\"style\"] = self.style\n    if self.vertical_content_alignment:\n        payload[\"verticalContentAlignment\"] = self.vertical_content_alignment\n    if self.bleed is not None:\n        payload[\"bleed\"] = self.bleed\n    if self.background_image:\n        payload[\"backgroundImage\"] = self.background_image\n    if self.min_height:\n        payload[\"minHeight\"] = self.min_height\n    if self.rtl is not None:\n        payload[\"rtl\"] = self.rtl\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableRow","title":"<code>TableRow</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Single row of a <code>Table</code> container.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class TableRow(CardContainer):\n\"\"\"Single row of a ``Table`` container.\"\"\"\n\n    def __init__(\n        self,\n        cells: list[TableCell],\n        style: Optional[types.ContainerStyleTypes] = None,\n    ) -&gt; None:\n\"\"\"Organizes cells into a row for a ``Table``.\n\n        Args:\n            cells: List of ``TableCells`` to include in the row.\n            style: Style hint for ``TableRow``.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.cells = cells\n        self.style = style\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload = {\"type\": \"TableRow\", \"cells\": [x.serialize() for x in self.cells]}\n        if self.style:\n            payload[\"style\"] = self.style\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableRow.__init__","title":"<code>__init__(cells, style=None)</code>","text":"<p>Organizes cells into a row for a <code>Table</code>.</p> <p>Parameters:</p> Name Type Description Default <code>cells</code> <code>list[TableCell]</code> <p>List of <code>TableCells</code> to include in the row.</p> required <code>style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Style hint for <code>TableRow</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    cells: list[TableCell],\n    style: Optional[types.ContainerStyleTypes] = None,\n) -&gt; None:\n\"\"\"Organizes cells into a row for a ``Table``.\n\n    Args:\n        cells: List of ``TableCells`` to include in the row.\n        style: Style hint for ``TableRow``.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.cells = cells\n    self.style = style\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.TableRow.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload = {\"type\": \"TableRow\", \"cells\": [x.serialize() for x in self.cells]}\n    if self.style:\n        payload[\"style\"] = self.style\n    return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Table","title":"<code>Table</code>","text":"<p>         Bases: <code>CardContainer</code></p> <p>Container for displaying tabular data.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Table.html</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>class Table(CardContainer):\n\"\"\"Container for displaying tabular data.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Table.html\n    \"\"\"\n\n    def __init__(\n        self,\n        columns: Optional[list[Column]] = None,\n        rows: Optional[list[TableRow]] = None,\n        first_row_as_headers: Optional[bool] = None,\n        show_grid_lines: Optional[bool] = None,\n        grid_style: Optional[types.ContainerStyleTypes] = None,\n        horizontal_cell_content_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n        vertical_cell_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n    ) -&gt; None:\n\"\"\"Provides a way to display data in a tabular form.\n\n        Args:\n            columns: List of ``Column`` elements to include.\n            rows: List of ``TableRow`` elements to include.\n            first_row_as_headers: Specifies whether the first row of the table should be treated\n                as a header row, and be announced as such by accessibility software.\n            show_grid_lines: Specifies whether grid lines should be displayed.\n            grid_style: Defines the style of the grid. This property currently only controls the\n                grid's color.\n            horizontal_cell_content_alignment: Controls how the content of all cells is horizontally\n                aligned by default. When not specified, horizontal alignment is defined on a\n                per-cell basis.\n            vertical_cell_content_alignment: Controls how the content of all cells is vertically\n                aligned by default. When not specified, vertical alignment is defined on a per-cell\n                basis.\n        \"\"\"\n        self.columns = columns\n        self.rows = rows\n        self.first_row_as_headers = first_row_as_headers\n        self.show_grid_lines = show_grid_lines\n        self.grid_style = grid_style\n        self.horizontal_cell_content_alignment = horizontal_cell_content_alignment\n        self.vertical_cell_content_alignment = vertical_cell_content_alignment\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\"type\": \"Table\"}\n        if self.columns:\n            payload[\"columns\"] = [x.serialize() for x in self.columns]\n        if self.rows:\n            payload[\"rows\"] = [x.serialize() for x in self.rows]\n        if self.first_row_as_headers is not None:\n            payload[\"firstRowAsHeaders\"] = self.first_row_as_headers\n        if self.show_grid_lines is not None:\n            payload[\"showGridLines\"] = self.show_grid_lines\n        if self.grid_style:\n            payload[\"gridStyle\"] = self.grid_style\n        if self.horizontal_cell_content_alignment:\n            payload[\"horizontalCellContentAlignment\"] = self.horizontal_cell_content_alignment\n        if self.vertical_cell_content_alignment:\n            payload[\"verticalCellContentAlignment\"] = self.vertical_cell_content_alignment\n        return payload\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Table.__init__","title":"<code>__init__(columns=None, rows=None, first_row_as_headers=None, show_grid_lines=None, grid_style=None, horizontal_cell_content_alignment=None, vertical_cell_content_alignment=None)</code>","text":"<p>Provides a way to display data in a tabular form.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>Optional[list[Column]]</code> <p>List of <code>Column</code> elements to include.</p> <code>None</code> <code>rows</code> <code>Optional[list[TableRow]]</code> <p>List of <code>TableRow</code> elements to include.</p> <code>None</code> <code>first_row_as_headers</code> <code>Optional[bool]</code> <p>Specifies whether the first row of the table should be treated as a header row, and be announced as such by accessibility software.</p> <code>None</code> <code>show_grid_lines</code> <code>Optional[bool]</code> <p>Specifies whether grid lines should be displayed.</p> <code>None</code> <code>grid_style</code> <code>Optional[types.ContainerStyleTypes]</code> <p>Defines the style of the grid. This property currently only controls the grid's color.</p> <code>None</code> <code>horizontal_cell_content_alignment</code> <code>Optional[types.HorizontalAlignmentTypes]</code> <p>Controls how the content of all cells is horizontally aligned by default. When not specified, horizontal alignment is defined on a per-cell basis.</p> <code>None</code> <code>vertical_cell_content_alignment</code> <code>Optional[types.VerticalAlignmentTypes]</code> <p>Controls how the content of all cells is vertically aligned by default. When not specified, vertical alignment is defined on a per-cell basis.</p> <code>None</code> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def __init__(\n    self,\n    columns: Optional[list[Column]] = None,\n    rows: Optional[list[TableRow]] = None,\n    first_row_as_headers: Optional[bool] = None,\n    show_grid_lines: Optional[bool] = None,\n    grid_style: Optional[types.ContainerStyleTypes] = None,\n    horizontal_cell_content_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n    vertical_cell_content_alignment: Optional[types.VerticalAlignmentTypes] = None,\n) -&gt; None:\n\"\"\"Provides a way to display data in a tabular form.\n\n    Args:\n        columns: List of ``Column`` elements to include.\n        rows: List of ``TableRow`` elements to include.\n        first_row_as_headers: Specifies whether the first row of the table should be treated\n            as a header row, and be announced as such by accessibility software.\n        show_grid_lines: Specifies whether grid lines should be displayed.\n        grid_style: Defines the style of the grid. This property currently only controls the\n            grid's color.\n        horizontal_cell_content_alignment: Controls how the content of all cells is horizontally\n            aligned by default. When not specified, horizontal alignment is defined on a\n            per-cell basis.\n        vertical_cell_content_alignment: Controls how the content of all cells is vertically\n            aligned by default. When not specified, vertical alignment is defined on a per-cell\n            basis.\n    \"\"\"\n    self.columns = columns\n    self.rows = rows\n    self.first_row_as_headers = first_row_as_headers\n    self.show_grid_lines = show_grid_lines\n    self.grid_style = grid_style\n    self.horizontal_cell_content_alignment = horizontal_cell_content_alignment\n    self.vertical_cell_content_alignment = vertical_cell_content_alignment\n</code></pre>"},{"location":"reference/containers/#msteams_webhooks.containers.Table.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/containers.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\"type\": \"Table\"}\n    if self.columns:\n        payload[\"columns\"] = [x.serialize() for x in self.columns]\n    if self.rows:\n        payload[\"rows\"] = [x.serialize() for x in self.rows]\n    if self.first_row_as_headers is not None:\n        payload[\"firstRowAsHeaders\"] = self.first_row_as_headers\n    if self.show_grid_lines is not None:\n        payload[\"showGridLines\"] = self.show_grid_lines\n    if self.grid_style:\n        payload[\"gridStyle\"] = self.grid_style\n    if self.horizontal_cell_content_alignment:\n        payload[\"horizontalCellContentAlignment\"] = self.horizontal_cell_content_alignment\n    if self.vertical_cell_content_alignment:\n        payload[\"verticalCellContentAlignment\"] = self.vertical_cell_content_alignment\n    return payload\n</code></pre>"},{"location":"reference/elements/","title":"Elements","text":"<p>Cards are built using various elements.</p>"},{"location":"reference/elements/#msteams_webhooks.elements.CardElement","title":"<code>CardElement</code>","text":"<p>         Bases: <code>Entity</code></p> <p>Base element class.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>class CardElement(Entity):\n\"\"\"Base element class.\"\"\"\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.TextBlock","title":"<code>TextBlock</code>","text":"<p>         Bases: <code>CardElement</code></p> <p>Displays text, allowing control over font sizes, weight, and color.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/TextBlock.html</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>class TextBlock(CardElement):\n\"\"\"Displays text, allowing control over font sizes, weight, and color.\n\n    Schema Explorer: https://adaptivecards.io/explorer/TextBlock.html\n    \"\"\"\n\n    def __init__(\n        self,\n        text: str,\n        *,\n        color: Optional[types.Colors] = None,\n        font_type: Optional[types.FontTypes] = None,\n        horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n        is_subtle: Optional[bool] = None,\n        max_lines: Optional[int] = None,\n        size: Optional[types.FontSizes] = None,\n        weight: Optional[types.FontWeights] = None,\n        wrap: Optional[bool] = None,\n        style: Optional[types.TextBlockStyles] = None,\n    ) -&gt; None:\n\"\"\"Build a TextBlock element.\n\n        Args:\n            text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n            color: Controls the color of TextBlock elements.\n            font_type: Type of font to use for rendering.\n            horizontal_alignment: Controls the horizontal text alignment. When not specified,\n                the value of horizontalAlignment is inherited from the parent container. If no\n                parent container has horizontalAlignment set, it defaults to Left.\n            is_subtle: If true, displays text slightly toned down to appear less prominent.\n                Default: ``False``\n            max_lines: Specifies the maximum number of lines to display. `text` will be\n                clipped if it exceeds `max_lines`.\n            size: Controls size of text.\n            weight: Controls the weight of TextBlock elements.\n            wrap: If true, allow `text` to wrap. Otherwise, text is clipped. Default: False\n            style: The style of this TextBlock for accessibility purposes.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.text = text\n        self.color = color\n        self.font_type = font_type\n        self.horizontal_alignment = horizontal_alignment\n        self.is_subtle = is_subtle\n        self.max_lines = max_lines\n        self.size = size\n        self.weight = weight\n        self.wrap = wrap\n        self.style = style\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\n            \"type\": \"TextBlock\",\n            \"text\": self.text,\n        }\n        if self.color:\n            payload[\"color\"] = self.color\n        if self.font_type:\n            payload[\"fontType\"] = self.font_type\n        if self.horizontal_alignment:\n            payload[\"horizontalAlignment\"] = self.horizontal_alignment\n        if self.is_subtle:\n            payload[\"isSubtle\"] = self.is_subtle\n        if self.max_lines:\n            payload[\"maxLines\"] = self.max_lines\n        if self.size:\n            payload[\"size\"] = self.size\n        if self.weight:\n            payload[\"weight\"] = self.weight\n        if self.wrap:\n            payload[\"wrap\"] = self.wrap\n        if self.style:\n            payload[\"style\"] = self.style\n        return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.TextBlock.__init__","title":"<code>__init__(text, *, color=None, font_type=None, horizontal_alignment=None, is_subtle=None, max_lines=None, size=None, weight=None, wrap=None, style=None)</code>","text":"<p>Build a TextBlock element.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)</p> required <code>color</code> <code>Optional[types.Colors]</code> <p>Controls the color of TextBlock elements.</p> <code>None</code> <code>font_type</code> <code>Optional[types.FontTypes]</code> <p>Type of font to use for rendering.</p> <code>None</code> <code>horizontal_alignment</code> <code>Optional[types.HorizontalAlignmentTypes]</code> <p>Controls the horizontal text alignment. When not specified, the value of horizontalAlignment is inherited from the parent container. If no parent container has horizontalAlignment set, it defaults to Left.</p> <code>None</code> <code>is_subtle</code> <code>Optional[bool]</code> <p>If true, displays text slightly toned down to appear less prominent. Default: <code>False</code></p> <code>None</code> <code>max_lines</code> <code>Optional[int]</code> <p>Specifies the maximum number of lines to display. <code>text</code> will be clipped if it exceeds <code>max_lines</code>.</p> <code>None</code> <code>size</code> <code>Optional[types.FontSizes]</code> <p>Controls size of text.</p> <code>None</code> <code>weight</code> <code>Optional[types.FontWeights]</code> <p>Controls the weight of TextBlock elements.</p> <code>None</code> <code>wrap</code> <code>Optional[bool]</code> <p>If true, allow <code>text</code> to wrap. Otherwise, text is clipped. Default: False</p> <code>None</code> <code>style</code> <code>Optional[types.TextBlockStyles]</code> <p>The style of this TextBlock for accessibility purposes.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def __init__(\n    self,\n    text: str,\n    *,\n    color: Optional[types.Colors] = None,\n    font_type: Optional[types.FontTypes] = None,\n    horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n    is_subtle: Optional[bool] = None,\n    max_lines: Optional[int] = None,\n    size: Optional[types.FontSizes] = None,\n    weight: Optional[types.FontWeights] = None,\n    wrap: Optional[bool] = None,\n    style: Optional[types.TextBlockStyles] = None,\n) -&gt; None:\n\"\"\"Build a TextBlock element.\n\n    Args:\n        text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n        color: Controls the color of TextBlock elements.\n        font_type: Type of font to use for rendering.\n        horizontal_alignment: Controls the horizontal text alignment. When not specified,\n            the value of horizontalAlignment is inherited from the parent container. If no\n            parent container has horizontalAlignment set, it defaults to Left.\n        is_subtle: If true, displays text slightly toned down to appear less prominent.\n            Default: ``False``\n        max_lines: Specifies the maximum number of lines to display. `text` will be\n            clipped if it exceeds `max_lines`.\n        size: Controls size of text.\n        weight: Controls the weight of TextBlock elements.\n        wrap: If true, allow `text` to wrap. Otherwise, text is clipped. Default: False\n        style: The style of this TextBlock for accessibility purposes.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.text = text\n    self.color = color\n    self.font_type = font_type\n    self.horizontal_alignment = horizontal_alignment\n    self.is_subtle = is_subtle\n    self.max_lines = max_lines\n    self.size = size\n    self.weight = weight\n    self.wrap = wrap\n    self.style = style\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.TextBlock.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\n        \"type\": \"TextBlock\",\n        \"text\": self.text,\n    }\n    if self.color:\n        payload[\"color\"] = self.color\n    if self.font_type:\n        payload[\"fontType\"] = self.font_type\n    if self.horizontal_alignment:\n        payload[\"horizontalAlignment\"] = self.horizontal_alignment\n    if self.is_subtle:\n        payload[\"isSubtle\"] = self.is_subtle\n    if self.max_lines:\n        payload[\"maxLines\"] = self.max_lines\n    if self.size:\n        payload[\"size\"] = self.size\n    if self.weight:\n        payload[\"weight\"] = self.weight\n    if self.wrap:\n        payload[\"wrap\"] = self.wrap\n    if self.style:\n        payload[\"style\"] = self.style\n    return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Image","title":"<code>Image</code>","text":"<p>         Bases: <code>CardElement</code></p> <p>Displays an image. Acceptable formats are PNG, JPEG, and GIF.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Image.html.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>class Image(CardElement):\n\"\"\"Displays an image. Acceptable formats are PNG, JPEG, and GIF.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Image.html.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: types.URL,\n        *,\n        alt_text: Optional[str] = None,\n        background_color: Optional[str] = None,\n        height: Optional[Union[str, Literal[\"auto\", \"stretch\"]]] = None,\n        horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n        select_action: Optional[Action] = None,\n        size: Optional[types.ImageSizeTypes] = None,\n        style: Optional[types.ImageStyleTypes] = None,\n        width: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"Displays an image. Acceptable formats are PNG, JPEG, and GIF.\n\n        Args:\n            url: The URL to the image. Supports data URI in version 1.2+.\n            alt_text: Alternate text describing the image.\n            background_color: Applies a background to a transparent image.\n                This property will respect the image style.\n            height: The desired height of the image. If specified as a pixel value,\n                ending in 'px', E.g., 50px, the image will distort to fit that exact\n                height. This overrides the size property.\n            horizontal_alignment: Controls how this element is horizontally positioned\n                within its parent. When not specified, the value of horizontalAlignment\n                is inherited from the parent container. If no parent container has\n                horizontalAlignment set, it defaults to Left.\n            select_action: An ``Action`` that will be invoked when the ``Image`` is tapped\n                or selected. ``Action.ShowCard`` is not supported.\n            size: Controls the approximate size of the image. The physical dimensions will\n                vary per host.\n            style: Controls how this ``Image`` is displayed.\n            width: The desired on-screen width of the image, ending in 'px'. E.g., 50px.\n                This overrides the size property.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.url = url\n        self.alt_text = alt_text\n        self.background_color = background_color\n        self.height = height\n        self.horizontal_alignment = horizontal_alignment\n        self.select_action = select_action\n        self.size = size\n        self.style = style\n        self.width = width\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\n            \"type\": \"Image\",\n            \"url\": self.url,\n        }\n        if self.alt_text:\n            payload[\"altText\"] = self.alt_text\n        if self.background_color:\n            payload[\"backgroundColor\"] = self.background_color\n        if self.height:\n            payload[\"height\"] = self.height\n        if self.horizontal_alignment:\n            payload[\"horizontalAlignment\"] = self.horizontal_alignment\n        if self.select_action:\n            payload[\"selectAction\"] = self.select_action.serialize()\n        if self.size:\n            payload[\"size\"] = self.size\n        if self.style:\n            payload[\"style\"] = self.style\n        if self.width:\n            payload[\"width\"] = self.width\n        return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Image.__init__","title":"<code>__init__(url, *, alt_text=None, background_color=None, height=None, horizontal_alignment=None, select_action=None, size=None, style=None, width=None)</code>","text":"<p>Displays an image. Acceptable formats are PNG, JPEG, and GIF.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>types.URL</code> <p>The URL to the image. Supports data URI in version 1.2+.</p> required <code>alt_text</code> <code>Optional[str]</code> <p>Alternate text describing the image.</p> <code>None</code> <code>background_color</code> <code>Optional[str]</code> <p>Applies a background to a transparent image. This property will respect the image style.</p> <code>None</code> <code>height</code> <code>Optional[Union[str, Literal['auto', 'stretch']]]</code> <p>The desired height of the image. If specified as a pixel value, ending in 'px', E.g., 50px, the image will distort to fit that exact height. This overrides the size property.</p> <code>None</code> <code>horizontal_alignment</code> <code>Optional[types.HorizontalAlignmentTypes]</code> <p>Controls how this element is horizontally positioned within its parent. When not specified, the value of horizontalAlignment is inherited from the parent container. If no parent container has horizontalAlignment set, it defaults to Left.</p> <code>None</code> <code>select_action</code> <code>Optional[Action]</code> <p>An <code>Action</code> that will be invoked when the <code>Image</code> is tapped or selected. <code>Action.ShowCard</code> is not supported.</p> <code>None</code> <code>size</code> <code>Optional[types.ImageSizeTypes]</code> <p>Controls the approximate size of the image. The physical dimensions will vary per host.</p> <code>None</code> <code>style</code> <code>Optional[types.ImageStyleTypes]</code> <p>Controls how this <code>Image</code> is displayed.</p> <code>None</code> <code>width</code> <code>Optional[str]</code> <p>The desired on-screen width of the image, ending in 'px'. E.g., 50px. This overrides the size property.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def __init__(\n    self,\n    url: types.URL,\n    *,\n    alt_text: Optional[str] = None,\n    background_color: Optional[str] = None,\n    height: Optional[Union[str, Literal[\"auto\", \"stretch\"]]] = None,\n    horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n    select_action: Optional[Action] = None,\n    size: Optional[types.ImageSizeTypes] = None,\n    style: Optional[types.ImageStyleTypes] = None,\n    width: Optional[str] = None,\n) -&gt; None:\n\"\"\"Displays an image. Acceptable formats are PNG, JPEG, and GIF.\n\n    Args:\n        url: The URL to the image. Supports data URI in version 1.2+.\n        alt_text: Alternate text describing the image.\n        background_color: Applies a background to a transparent image.\n            This property will respect the image style.\n        height: The desired height of the image. If specified as a pixel value,\n            ending in 'px', E.g., 50px, the image will distort to fit that exact\n            height. This overrides the size property.\n        horizontal_alignment: Controls how this element is horizontally positioned\n            within its parent. When not specified, the value of horizontalAlignment\n            is inherited from the parent container. If no parent container has\n            horizontalAlignment set, it defaults to Left.\n        select_action: An ``Action`` that will be invoked when the ``Image`` is tapped\n            or selected. ``Action.ShowCard`` is not supported.\n        size: Controls the approximate size of the image. The physical dimensions will\n            vary per host.\n        style: Controls how this ``Image`` is displayed.\n        width: The desired on-screen width of the image, ending in 'px'. E.g., 50px.\n            This overrides the size property.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.url = url\n    self.alt_text = alt_text\n    self.background_color = background_color\n    self.height = height\n    self.horizontal_alignment = horizontal_alignment\n    self.select_action = select_action\n    self.size = size\n    self.style = style\n    self.width = width\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Image.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\n        \"type\": \"Image\",\n        \"url\": self.url,\n    }\n    if self.alt_text:\n        payload[\"altText\"] = self.alt_text\n    if self.background_color:\n        payload[\"backgroundColor\"] = self.background_color\n    if self.height:\n        payload[\"height\"] = self.height\n    if self.horizontal_alignment:\n        payload[\"horizontalAlignment\"] = self.horizontal_alignment\n    if self.select_action:\n        payload[\"selectAction\"] = self.select_action.serialize()\n    if self.size:\n        payload[\"size\"] = self.size\n    if self.style:\n        payload[\"style\"] = self.style\n    if self.width:\n        payload[\"width\"] = self.width\n    return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.MediaSource","title":"<code>MediaSource</code>","text":"<p>         Bases: <code>CardElement</code></p> <p>Defines a source for a Media element.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/MediaSource.html</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>class MediaSource(CardElement):\n\"\"\"Defines a source for a Media element.\n\n    Schema Explorer: https://adaptivecards.io/explorer/MediaSource.html\n    \"\"\"\n\n    def __init__(self, url: types.URL, *, mime_type: Optional[str] = None) -&gt; None:\n\"\"\"Defines a source for a Media element.\n\n        Args:\n            url: URL to media. Supports data URI in version 1.2+\n            mime_type: Mime type of associated media (e.g. \"video/mp4\"). For YouTube\n                and other Web video URLs, mime_type can be omitted.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.url = url\n        self.mime_type = mime_type\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\"url\": self.url}\n        if self.mime_type:\n            payload[\"mimeType\"] = self.mime_type\n        return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.MediaSource.__init__","title":"<code>__init__(url, *, mime_type=None)</code>","text":"<p>Defines a source for a Media element.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>types.URL</code> <p>URL to media. Supports data URI in version 1.2+</p> required <code>mime_type</code> <code>Optional[str]</code> <p>Mime type of associated media (e.g. \"video/mp4\"). For YouTube and other Web video URLs, mime_type can be omitted.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def __init__(self, url: types.URL, *, mime_type: Optional[str] = None) -&gt; None:\n\"\"\"Defines a source for a Media element.\n\n    Args:\n        url: URL to media. Supports data URI in version 1.2+\n        mime_type: Mime type of associated media (e.g. \"video/mp4\"). For YouTube\n            and other Web video URLs, mime_type can be omitted.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.url = url\n    self.mime_type = mime_type\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.MediaSource.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\"url\": self.url}\n    if self.mime_type:\n        payload[\"mimeType\"] = self.mime_type\n    return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Media","title":"<code>Media</code>","text":"<p>         Bases: <code>CardElement</code></p> <p>Displays a media player for audio or video content.</p> <p>Schema Explorer: https://adaptivecards.io/explorer/Media.html</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>class Media(CardElement):\n\"\"\"Displays a media player for audio or video content.\n\n    Schema Explorer: https://adaptivecards.io/explorer/Media.html\n    \"\"\"\n\n    def __init__(\n        self,\n        sources: list[MediaSource],\n        *,\n        poster: Optional[types.URL] = None,\n        alt_text: Optional[str] = None,\n    ) -&gt; None:\n\"\"\"Displays a media player for audio or video content.\n\n        Args:\n            sources: List of ``MediaSource`` elements to display.\n            poster: URL of an image to display before playing. Supports data URI in version 1.2+.\n                If poster is omitted, the Media element will either use a default poster\n                (controlled by the host application) or will attempt to automatically pull\n                the poster from the target video service when the source URL points to a\n                video from a Web provider such as YouTube.\n            alt_text: Alternate text describing the audio or video.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.sources = sources\n        self.poster = poster\n        self.alt_text = alt_text\n\n    def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n        payload: dict[str, Any] = {\n            \"type\": \"Media\",\n            \"sources\": [x.serialize() for x in self.sources],\n        }\n        if self.poster:\n            payload[\"poster\"] = self.poster\n        if self.alt_text:\n            payload[\"altText\"] = self.alt_text\n        return payload\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Media.__init__","title":"<code>__init__(sources, *, poster=None, alt_text=None)</code>","text":"<p>Displays a media player for audio or video content.</p> <p>Parameters:</p> Name Type Description Default <code>sources</code> <code>list[MediaSource]</code> <p>List of <code>MediaSource</code> elements to display.</p> required <code>poster</code> <code>Optional[types.URL]</code> <p>URL of an image to display before playing. Supports data URI in version 1.2+. If poster is omitted, the Media element will either use a default poster (controlled by the host application) or will attempt to automatically pull the poster from the target video service when the source URL points to a video from a Web provider such as YouTube.</p> <code>None</code> <code>alt_text</code> <code>Optional[str]</code> <p>Alternate text describing the audio or video.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def __init__(\n    self,\n    sources: list[MediaSource],\n    *,\n    poster: Optional[types.URL] = None,\n    alt_text: Optional[str] = None,\n) -&gt; None:\n\"\"\"Displays a media player for audio or video content.\n\n    Args:\n        sources: List of ``MediaSource`` elements to display.\n        poster: URL of an image to display before playing. Supports data URI in version 1.2+.\n            If poster is omitted, the Media element will either use a default poster\n            (controlled by the host application) or will attempt to automatically pull\n            the poster from the target video service when the source URL points to a\n            video from a Web provider such as YouTube.\n        alt_text: Alternate text describing the audio or video.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.sources = sources\n    self.poster = poster\n    self.alt_text = alt_text\n</code></pre>"},{"location":"reference/elements/#msteams_webhooks.elements.Media.serialize","title":"<code>serialize()</code>","text":"<p>Serialize object into data structure.</p> Source code in <code>msteams_webhooks/elements.py</code> <pre><code>def serialize(self) -&gt; dict[str, Any]:\n\"\"\"Serialize object into data structure.\"\"\"\n    payload: dict[str, Any] = {\n        \"type\": \"Media\",\n        \"sources\": [x.serialize() for x in self.sources],\n    }\n    if self.poster:\n        payload[\"poster\"] = self.poster\n    if self.alt_text:\n        payload[\"altText\"] = self.alt_text\n    return payload\n</code></pre>"},{"location":"reference/teams_webhook/","title":"TeamsWebhook","text":"<p>Core webhook class.</p> <p>Dispatches messages to webhook URL.</p> Source code in <code>msteams_webhooks/__init__.py</code> <pre><code>class TeamsWebhook:\n\"\"\"Core webhook class.\n\n    Dispatches messages to webhook URL.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: types.URL,\n        *,\n        verify: Union[str, bool, ssl.SSLContext] = True,\n        timeout: float = 15.0,\n    ) -&gt; None:\n\"\"\"Construct webhook object.\n\n        Args:\n            url: Teams webhook URL to send all cards (messages) to.\n            verify: How to handle HTTPS certificate verification.\n            timeout: Global timeout in seconds for all HTTP operations.\n                May be further tuned with an ``httpx.Timeout`` object.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        self.url = url\n        self.client = httpx.Client(verify=verify, timeout=timeout)\n        self.response = None\n\n    def send_card(self, card: Card) -&gt; None:\n\"\"\"Sends a card to the channel.\n\n        Args:\n            card: The ``Card`` to send. Only one card may be sent at a time.\n\n        Returns:\n            None.\n\n        Raises:\n            TeamsWebhookError: if the response was anything other than 200/OK.\n            TeamsRateLimitError: if \"429\" was found inside the response body.\n        \"\"\"\n        headers = {\"Content-Type\": \"application/json\"}\n        # Even though the attachments key as a list implies that more than one card\n        # may be sent in a single webhook call, this is not the case. If you send more\n        # than one card, only the first will be posted to the channel.\n        data = {\"type\": \"message\", \"attachments\": [card.serialize()]}\n        self.response = self.client.post(self.url, json=data, headers=headers)\n        if self.response.status_code != httpx.codes.OK:\n            raise TeamsWebhookError(self.response.text)\n        if \"429\" in self.response.text:\n            # Rate limit errors receive HTTP code 200 with 429 in response body.\n            raise TeamsRateLimitError(\"Rate limit exceeded. Slow messaging rate and try again.\")\n\n    def send_message(\n        self,\n        text: str,\n        *,\n        color: Optional[types.Colors] = None,\n        font_type: Optional[types.FontTypes] = None,\n        horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n        is_subtle: Optional[bool] = None,\n        max_lines: Optional[int] = None,\n        size: Optional[types.FontSizes] = None,\n        weight: Optional[types.FontWeights] = None,\n        style: Optional[types.TextBlockStyles] = None,\n        wrap: bool = True,\n    ) -&gt; None:\n\"\"\"Sends a basic text message to the channel.\n\n        Convenience method that builds an ``AdaptiveCard`` and adds a single ``TextBlock``\n        element to its body, with optional formatting.\n\n        Args:\n            text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n            color: Controls the color of TextBlock elements.\n            font_type: Type of font to use for rendering.\n            horizontal_alignment: Controls the horizontal text alignment. When not specified,\n                the value of horizontalAlignment is inherited from the parent container. If no\n                parent container has horizontalAlignment set, it defaults to Left.\n            is_subtle: If true, displays text slightly toned down to appear less prominent.\n                Default: ``False``\n            max_lines: Specifies the maximum number of lines to display. `text` will be\n                clipped if it exceeds `max_lines`.\n            size: Controls size of text.\n            weight: Controls the weight of TextBlock elements.\n            wrap: If true, allow `text` to wrap. Otherwise, text is clipped. Default: False\n            style: The style of this TextBlock for accessibility purposes.\n\n        Returns:\n            None.\n\n        Raises:\n            N/A\n        \"\"\"\n        text_block = TextBlock(\n            text=text,\n            color=color,\n            font_type=font_type,\n            horizontal_alignment=horizontal_alignment,\n            is_subtle=is_subtle,\n            max_lines=max_lines,\n            size=size,\n            weight=weight,\n            wrap=wrap,\n            style=style,\n        )\n        self.send_card(card=AdaptiveCard(body=[text_block]))\n</code></pre>"},{"location":"reference/teams_webhook/#msteams_webhooks.TeamsWebhook.__init__","title":"<code>__init__(url, *, verify=True, timeout=15.0)</code>","text":"<p>Construct webhook object.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>types.URL</code> <p>Teams webhook URL to send all cards (messages) to.</p> required <code>verify</code> <code>Union[str, bool, ssl.SSLContext]</code> <p>How to handle HTTPS certificate verification.</p> <code>True</code> <code>timeout</code> <code>float</code> <p>Global timeout in seconds for all HTTP operations. May be further tuned with an <code>httpx.Timeout</code> object.</p> <code>15.0</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/__init__.py</code> <pre><code>def __init__(\n    self,\n    url: types.URL,\n    *,\n    verify: Union[str, bool, ssl.SSLContext] = True,\n    timeout: float = 15.0,\n) -&gt; None:\n\"\"\"Construct webhook object.\n\n    Args:\n        url: Teams webhook URL to send all cards (messages) to.\n        verify: How to handle HTTPS certificate verification.\n        timeout: Global timeout in seconds for all HTTP operations.\n            May be further tuned with an ``httpx.Timeout`` object.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    self.url = url\n    self.client = httpx.Client(verify=verify, timeout=timeout)\n    self.response = None\n</code></pre>"},{"location":"reference/teams_webhook/#msteams_webhooks.TeamsWebhook.send_card","title":"<code>send_card(card)</code>","text":"<p>Sends a card to the channel.</p> <p>Parameters:</p> Name Type Description Default <code>card</code> <code>Card</code> <p>The <code>Card</code> to send. Only one card may be sent at a time.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Raises:</p> Type Description <code>TeamsWebhookError</code> <p>if the response was anything other than 200/OK.</p> <code>TeamsRateLimitError</code> <p>if \"429\" was found inside the response body.</p> Source code in <code>msteams_webhooks/__init__.py</code> <pre><code>def send_card(self, card: Card) -&gt; None:\n\"\"\"Sends a card to the channel.\n\n    Args:\n        card: The ``Card`` to send. Only one card may be sent at a time.\n\n    Returns:\n        None.\n\n    Raises:\n        TeamsWebhookError: if the response was anything other than 200/OK.\n        TeamsRateLimitError: if \"429\" was found inside the response body.\n    \"\"\"\n    headers = {\"Content-Type\": \"application/json\"}\n    # Even though the attachments key as a list implies that more than one card\n    # may be sent in a single webhook call, this is not the case. If you send more\n    # than one card, only the first will be posted to the channel.\n    data = {\"type\": \"message\", \"attachments\": [card.serialize()]}\n    self.response = self.client.post(self.url, json=data, headers=headers)\n    if self.response.status_code != httpx.codes.OK:\n        raise TeamsWebhookError(self.response.text)\n    if \"429\" in self.response.text:\n        # Rate limit errors receive HTTP code 200 with 429 in response body.\n        raise TeamsRateLimitError(\"Rate limit exceeded. Slow messaging rate and try again.\")\n</code></pre>"},{"location":"reference/teams_webhook/#msteams_webhooks.TeamsWebhook.send_message","title":"<code>send_message(text, *, color=None, font_type=None, horizontal_alignment=None, is_subtle=None, max_lines=None, size=None, weight=None, style=None, wrap=True)</code>","text":"<p>Sends a basic text message to the channel.</p> <p>Convenience method that builds an <code>AdaptiveCard</code> and adds a single <code>TextBlock</code> element to its body, with optional formatting.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)</p> required <code>color</code> <code>Optional[types.Colors]</code> <p>Controls the color of TextBlock elements.</p> <code>None</code> <code>font_type</code> <code>Optional[types.FontTypes]</code> <p>Type of font to use for rendering.</p> <code>None</code> <code>horizontal_alignment</code> <code>Optional[types.HorizontalAlignmentTypes]</code> <p>Controls the horizontal text alignment. When not specified, the value of horizontalAlignment is inherited from the parent container. If no parent container has horizontalAlignment set, it defaults to Left.</p> <code>None</code> <code>is_subtle</code> <code>Optional[bool]</code> <p>If true, displays text slightly toned down to appear less prominent. Default: <code>False</code></p> <code>None</code> <code>max_lines</code> <code>Optional[int]</code> <p>Specifies the maximum number of lines to display. <code>text</code> will be clipped if it exceeds <code>max_lines</code>.</p> <code>None</code> <code>size</code> <code>Optional[types.FontSizes]</code> <p>Controls size of text.</p> <code>None</code> <code>weight</code> <code>Optional[types.FontWeights]</code> <p>Controls the weight of TextBlock elements.</p> <code>None</code> <code>wrap</code> <code>bool</code> <p>If true, allow <code>text</code> to wrap. Otherwise, text is clipped. Default: False</p> <code>True</code> <code>style</code> <code>Optional[types.TextBlockStyles]</code> <p>The style of this TextBlock for accessibility purposes.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None.</p> Source code in <code>msteams_webhooks/__init__.py</code> <pre><code>def send_message(\n    self,\n    text: str,\n    *,\n    color: Optional[types.Colors] = None,\n    font_type: Optional[types.FontTypes] = None,\n    horizontal_alignment: Optional[types.HorizontalAlignmentTypes] = None,\n    is_subtle: Optional[bool] = None,\n    max_lines: Optional[int] = None,\n    size: Optional[types.FontSizes] = None,\n    weight: Optional[types.FontWeights] = None,\n    style: Optional[types.TextBlockStyles] = None,\n    wrap: bool = True,\n) -&gt; None:\n\"\"\"Sends a basic text message to the channel.\n\n    Convenience method that builds an ``AdaptiveCard`` and adds a single ``TextBlock``\n    element to its body, with optional formatting.\n\n    Args:\n        text: Text to display. A subset of markdown is supported (https://aka.ms/ACTextFeatures)\n        color: Controls the color of TextBlock elements.\n        font_type: Type of font to use for rendering.\n        horizontal_alignment: Controls the horizontal text alignment. When not specified,\n            the value of horizontalAlignment is inherited from the parent container. If no\n            parent container has horizontalAlignment set, it defaults to Left.\n        is_subtle: If true, displays text slightly toned down to appear less prominent.\n            Default: ``False``\n        max_lines: Specifies the maximum number of lines to display. `text` will be\n            clipped if it exceeds `max_lines`.\n        size: Controls size of text.\n        weight: Controls the weight of TextBlock elements.\n        wrap: If true, allow `text` to wrap. Otherwise, text is clipped. Default: False\n        style: The style of this TextBlock for accessibility purposes.\n\n    Returns:\n        None.\n\n    Raises:\n        N/A\n    \"\"\"\n    text_block = TextBlock(\n        text=text,\n        color=color,\n        font_type=font_type,\n        horizontal_alignment=horizontal_alignment,\n        is_subtle=is_subtle,\n        max_lines=max_lines,\n        size=size,\n        weight=weight,\n        wrap=wrap,\n        style=style,\n    )\n    self.send_card(card=AdaptiveCard(body=[text_block]))\n</code></pre>"}]}